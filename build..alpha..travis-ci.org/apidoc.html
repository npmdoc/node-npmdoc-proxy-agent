<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/TooTallNate/node-proxy-agent"

    >proxy-agent (v2.0.0)</a>
</h1>
<h4>Maps proxy protocols to `http.Agent` implementations</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.proxy-agent">module proxy-agent</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxy-agent.proxy-agent">
            function <span class="apidocSignatureSpan"></span>proxy-agent
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxy-agent.proxies.socks">
            function <span class="apidocSignatureSpan">proxy-agent.</span>proxies.socks
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxy-agent.super_">
            function <span class="apidocSignatureSpan">proxy-agent.</span>super_
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">proxy-agent.</span>cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">proxy-agent.</span>proxies</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">proxy-agent.</span>super_.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.proxy-agent.cache">module proxy-agent.cache</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">proxy-agent.cache.</span>_allowStale</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxy-agent.cache._lengthCalculator">
            function <span class="apidocSignatureSpan">proxy-agent.cache.</span>_lengthCalculator
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">proxy-agent.cache.</span>_itemCount</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">proxy-agent.cache.</span>_length</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">proxy-agent.cache.</span>_lru</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">proxy-agent.cache.</span>_max</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">proxy-agent.cache.</span>_mru</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">proxy-agent.cache.</span>_cache</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">proxy-agent.cache.</span>_lruList</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">proxy-agent.cache.</span>_maxAge</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.proxy-agent.proxies">module proxy-agent.proxies</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxy-agent.proxies.http">
            function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>http
            <span class="apidocSignatureSpan">(opts, secureEndpoint)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxy-agent.proxies.https">
            function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>https
            <span class="apidocSignatureSpan">(opts, secureEndpoint)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxy-agent.proxies.socks">
            function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>socks
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxy-agent.proxies.socks4">
            function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>socks4
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxy-agent.proxies.socks4a">
            function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>socks4a
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxy-agent.proxies.socks5">
            function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>socks5
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxy-agent.proxies.socks5h">
            function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>socks5h
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.proxy-agent.proxies.socks">module proxy-agent.proxies.socks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxy-agent.proxies.socks.socks">
            function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>socks
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxy-agent.proxies.socks.super_">
            function <span class="apidocSignatureSpan">proxy-agent.proxies.socks.</span>super_
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.proxy-agent.super_">module proxy-agent.super_</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxy-agent.super_.super_">
            function <span class="apidocSignatureSpan">proxy-agent.</span>super_
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.proxy-agent.super_.prototype">module proxy-agent.super_.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.proxy-agent.super_.prototype.addRequest">
            function <span class="apidocSignatureSpan">proxy-agent.super_.prototype.</span>addRequest
            <span class="apidocSignatureSpan">(req, host, port, localAddress)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.proxy-agent" id="apidoc.module.proxy-agent">module proxy-agent</a></h1>


    <h2>
        <a href="#apidoc.element.proxy-agent.proxy-agent" id="apidoc.element.proxy-agent.proxy-agent">
        function <span class="apidocSignatureSpan"></span>proxy-agent
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ProxyAgent(opts) {
  if (!(this instanceof ProxyAgent)) return new ProxyAgent(opts);
  if (&#x27;string&#x27; == typeof opts) opts = url.parse(opts);
  if (!opts) throw new TypeError(&#x27;an HTTP(S) proxy server `host` and `protocol` must be specified!&#x27;);
  debug(&#x27;creating new ProxyAgent instance: %o&#x27;, opts);
  Agent.call(this, connect);

  var proxies;
  if (opts.proxies) {
    proxies = extend(Object.create(exports.proxies), opts.proxies);
  } else {
    proxies = exports.proxies;
  }

  // get the requested proxy &#x22;protocol&#x22;
  var protocol = opts.protocol;
  if (!protocol) {
    throw new TypeError(&#x27;You must specify a string &#x22;protocol&#x22; for the &#x27; +
                        &#x27;proxy type (&#x27; + types().join(&#x27;, &#x27;) + &#x27;)&#x27;);
  }

  // strip the trailing &#x22;:&#x22; if present
  if (&#x27;:&#x27; == protocol[protocol.length - 1]) {
    protocol = protocol.substring(0, protocol.length - 1);
  }

  // get the proxy `http.Agent` creation function
  var proxyFn = proxies[protocol];
  if (&#x27;function&#x27; != typeof proxyFn) {
    throw new TypeError(&#x27;unsupported proxy protocol: &#x22;&#x27; + protocol + &#x27;&#x22;&#x27;);
  }

  this.proxy = opts;
  // format the proxy info back into a URI, since an opts object
  // could have been passed in originally. This generated URI is used
  // as part of the &#x22;key&#x22; for the LRU cache
  this.proxyUri = url.format({
    protocol: protocol + &#x27;:&#x27;,
    slashes: true,
    hostname: opts.hostname || opts.host,
    port: opts.port
  });
  this.proxyFn = proxyFn;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxy-agent.proxies.socks" id="apidoc.element.proxy-agent.proxies.socks">
        function <span class="apidocSignatureSpan">proxy-agent.</span>proxies.socks
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocksProxyAgent(opts) {
  if (!(this instanceof SocksProxyAgent)) return new SocksProxyAgent(opts);
  if (&#x27;string&#x27; == typeof opts) opts = url.parse(opts);
  if (!opts) throw new Error(&#x27;a SOCKS proxy server `host` and `port` must be specified!&#x27;);
  Agent.call(this, connect);

  var proxy = extend({}, opts);

  // prefer `hostname` over `host`, because of `url.parse()`
  proxy.host = proxy.hostname || proxy.host;

  // SOCKS doesn&#x27;t *technically* have a default port, but this is
  // the same default that `curl(1)` uses
  proxy.port = +proxy.port || 1080;

  if (proxy.host &#x26;&#x26; proxy.path) {
    // if both a `host` and `path` are specified then it&#x27;s most likely the
    // result of a `url.parse()` call... we need to remove the `path` portion so
    // that `net.connect()` doesn&#x27;t attempt to open that as a unix socket file.
    delete proxy.path;
    delete proxy.pathname;
  }

  // figure out if we want socks v4 or v5, based on the &#x22;protocol&#x22; used.
  // Defaults to 5.
  proxy.lookup = false;
  switch (proxy.protocol) {
    case &#x27;socks4:&#x27;:
      proxy.lookup = true;
      // pass through
    case &#x27;socks4a:&#x27;:
      proxy.version = 4;
      break;
    case &#x27;socks5:&#x27;:
      proxy.lookup = true;
      // pass through
    case &#x27;socks:&#x27;: // no version specified, default to 5h
    case &#x27;socks5h:&#x27;:
      proxy.version = 5;
      break;
    default:
      throw new TypeError(&#x27;A &#x22;socks&#x22; protocol must be specified! Got: &#x27; + proxy.protocol);
  }

  this.proxy = proxy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxy-agent.super_" id="apidoc.element.proxy-agent.super_">
        function <span class="apidocSignatureSpan">proxy-agent.</span>super_
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(callback) {
  if (!(this instanceof Agent)) return new Agent(callback);
  if (&#x27;function&#x27; != typeof callback) throw new Error(&#x27;Must pass a &#x22;callback function&#x22;&#x27;);
  EventEmitter.call(this);
  this.callback = callback;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.proxy-agent.cache" id="apidoc.module.proxy-agent.cache">module proxy-agent.cache</a></h1>




    <h2>
        <a href="#apidoc.element.proxy-agent.cache._lengthCalculator" id="apidoc.element.proxy-agent.cache._lengthCalculator">
        function <span class="apidocSignatureSpan">proxy-agent.cache.</span>_lengthCalculator
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function naiveLength() { return 1 }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.proxy-agent.proxies" id="apidoc.module.proxy-agent.proxies">module proxy-agent.proxies</a></h1>


    <h2>
        <a href="#apidoc.element.proxy-agent.proxies.http" id="apidoc.element.proxy-agent.proxies.http">
        function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>http
        <span class="apidocSignatureSpan">(opts, secureEndpoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function httpOrHttpsProxy(opts, secureEndpoint) {
  if (secureEndpoint) {
    // HTTPS
    return new HttpsProxyAgent(opts);
  } else {
    // HTTP
    return new HttpProxyAgent(opts);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxy-agent.proxies.https" id="apidoc.element.proxy-agent.proxies.https">
        function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>https
        <span class="apidocSignatureSpan">(opts, secureEndpoint)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function httpOrHttpsProxy(opts, secureEndpoint) {
  if (secureEndpoint) {
    // HTTPS
    return new HttpsProxyAgent(opts);
  } else {
    // HTTP
    return new HttpProxyAgent(opts);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxy-agent.proxies.socks" id="apidoc.element.proxy-agent.proxies.socks">
        function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>socks
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocksProxyAgent(opts) {
  if (!(this instanceof SocksProxyAgent)) return new SocksProxyAgent(opts);
  if (&#x27;string&#x27; == typeof opts) opts = url.parse(opts);
  if (!opts) throw new Error(&#x27;a SOCKS proxy server `host` and `port` must be specified!&#x27;);
  Agent.call(this, connect);

  var proxy = extend({}, opts);

  // prefer `hostname` over `host`, because of `url.parse()`
  proxy.host = proxy.hostname || proxy.host;

  // SOCKS doesn&#x27;t *technically* have a default port, but this is
  // the same default that `curl(1)` uses
  proxy.port = +proxy.port || 1080;

  if (proxy.host &#x26;&#x26; proxy.path) {
    // if both a `host` and `path` are specified then it&#x27;s most likely the
    // result of a `url.parse()` call... we need to remove the `path` portion so
    // that `net.connect()` doesn&#x27;t attempt to open that as a unix socket file.
    delete proxy.path;
    delete proxy.pathname;
  }

  // figure out if we want socks v4 or v5, based on the &#x22;protocol&#x22; used.
  // Defaults to 5.
  proxy.lookup = false;
  switch (proxy.protocol) {
    case &#x27;socks4:&#x27;:
      proxy.lookup = true;
      // pass through
    case &#x27;socks4a:&#x27;:
      proxy.version = 4;
      break;
    case &#x27;socks5:&#x27;:
      proxy.lookup = true;
      // pass through
    case &#x27;socks:&#x27;: // no version specified, default to 5h
    case &#x27;socks5h:&#x27;:
      proxy.version = 5;
      break;
    default:
      throw new TypeError(&#x27;A &#x22;socks&#x22; protocol must be specified! Got: &#x27; + proxy.protocol);
  }

  this.proxy = proxy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxy-agent.proxies.socks4" id="apidoc.element.proxy-agent.proxies.socks4">
        function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>socks4
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocksProxyAgent(opts) {
  if (!(this instanceof SocksProxyAgent)) return new SocksProxyAgent(opts);
  if (&#x27;string&#x27; == typeof opts) opts = url.parse(opts);
  if (!opts) throw new Error(&#x27;a SOCKS proxy server `host` and `port` must be specified!&#x27;);
  Agent.call(this, connect);

  var proxy = extend({}, opts);

  // prefer `hostname` over `host`, because of `url.parse()`
  proxy.host = proxy.hostname || proxy.host;

  // SOCKS doesn&#x27;t *technically* have a default port, but this is
  // the same default that `curl(1)` uses
  proxy.port = +proxy.port || 1080;

  if (proxy.host &#x26;&#x26; proxy.path) {
    // if both a `host` and `path` are specified then it&#x27;s most likely the
    // result of a `url.parse()` call... we need to remove the `path` portion so
    // that `net.connect()` doesn&#x27;t attempt to open that as a unix socket file.
    delete proxy.path;
    delete proxy.pathname;
  }

  // figure out if we want socks v4 or v5, based on the &#x22;protocol&#x22; used.
  // Defaults to 5.
  proxy.lookup = false;
  switch (proxy.protocol) {
    case &#x27;socks4:&#x27;:
      proxy.lookup = true;
      // pass through
    case &#x27;socks4a:&#x27;:
      proxy.version = 4;
      break;
    case &#x27;socks5:&#x27;:
      proxy.lookup = true;
      // pass through
    case &#x27;socks:&#x27;: // no version specified, default to 5h
    case &#x27;socks5h:&#x27;:
      proxy.version = 5;
      break;
    default:
      throw new TypeError(&#x27;A &#x22;socks&#x22; protocol must be specified! Got: &#x27; + proxy.protocol);
  }

  this.proxy = proxy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxy-agent.proxies.socks4a" id="apidoc.element.proxy-agent.proxies.socks4a">
        function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>socks4a
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocksProxyAgent(opts) {
  if (!(this instanceof SocksProxyAgent)) return new SocksProxyAgent(opts);
  if (&#x27;string&#x27; == typeof opts) opts = url.parse(opts);
  if (!opts) throw new Error(&#x27;a SOCKS proxy server `host` and `port` must be specified!&#x27;);
  Agent.call(this, connect);

  var proxy = extend({}, opts);

  // prefer `hostname` over `host`, because of `url.parse()`
  proxy.host = proxy.hostname || proxy.host;

  // SOCKS doesn&#x27;t *technically* have a default port, but this is
  // the same default that `curl(1)` uses
  proxy.port = +proxy.port || 1080;

  if (proxy.host &#x26;&#x26; proxy.path) {
    // if both a `host` and `path` are specified then it&#x27;s most likely the
    // result of a `url.parse()` call... we need to remove the `path` portion so
    // that `net.connect()` doesn&#x27;t attempt to open that as a unix socket file.
    delete proxy.path;
    delete proxy.pathname;
  }

  // figure out if we want socks v4 or v5, based on the &#x22;protocol&#x22; used.
  // Defaults to 5.
  proxy.lookup = false;
  switch (proxy.protocol) {
    case &#x27;socks4:&#x27;:
      proxy.lookup = true;
      // pass through
    case &#x27;socks4a:&#x27;:
      proxy.version = 4;
      break;
    case &#x27;socks5:&#x27;:
      proxy.lookup = true;
      // pass through
    case &#x27;socks:&#x27;: // no version specified, default to 5h
    case &#x27;socks5h:&#x27;:
      proxy.version = 5;
      break;
    default:
      throw new TypeError(&#x27;A &#x22;socks&#x22; protocol must be specified! Got: &#x27; + proxy.protocol);
  }

  this.proxy = proxy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxy-agent.proxies.socks5" id="apidoc.element.proxy-agent.proxies.socks5">
        function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>socks5
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocksProxyAgent(opts) {
  if (!(this instanceof SocksProxyAgent)) return new SocksProxyAgent(opts);
  if (&#x27;string&#x27; == typeof opts) opts = url.parse(opts);
  if (!opts) throw new Error(&#x27;a SOCKS proxy server `host` and `port` must be specified!&#x27;);
  Agent.call(this, connect);

  var proxy = extend({}, opts);

  // prefer `hostname` over `host`, because of `url.parse()`
  proxy.host = proxy.hostname || proxy.host;

  // SOCKS doesn&#x27;t *technically* have a default port, but this is
  // the same default that `curl(1)` uses
  proxy.port = +proxy.port || 1080;

  if (proxy.host &#x26;&#x26; proxy.path) {
    // if both a `host` and `path` are specified then it&#x27;s most likely the
    // result of a `url.parse()` call... we need to remove the `path` portion so
    // that `net.connect()` doesn&#x27;t attempt to open that as a unix socket file.
    delete proxy.path;
    delete proxy.pathname;
  }

  // figure out if we want socks v4 or v5, based on the &#x22;protocol&#x22; used.
  // Defaults to 5.
  proxy.lookup = false;
  switch (proxy.protocol) {
    case &#x27;socks4:&#x27;:
      proxy.lookup = true;
      // pass through
    case &#x27;socks4a:&#x27;:
      proxy.version = 4;
      break;
    case &#x27;socks5:&#x27;:
      proxy.lookup = true;
      // pass through
    case &#x27;socks:&#x27;: // no version specified, default to 5h
    case &#x27;socks5h:&#x27;:
      proxy.version = 5;
      break;
    default:
      throw new TypeError(&#x27;A &#x22;socks&#x22; protocol must be specified! Got: &#x27; + proxy.protocol);
  }

  this.proxy = proxy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxy-agent.proxies.socks5h" id="apidoc.element.proxy-agent.proxies.socks5h">
        function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>socks5h
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocksProxyAgent(opts) {
  if (!(this instanceof SocksProxyAgent)) return new SocksProxyAgent(opts);
  if (&#x27;string&#x27; == typeof opts) opts = url.parse(opts);
  if (!opts) throw new Error(&#x27;a SOCKS proxy server `host` and `port` must be specified!&#x27;);
  Agent.call(this, connect);

  var proxy = extend({}, opts);

  // prefer `hostname` over `host`, because of `url.parse()`
  proxy.host = proxy.hostname || proxy.host;

  // SOCKS doesn&#x27;t *technically* have a default port, but this is
  // the same default that `curl(1)` uses
  proxy.port = +proxy.port || 1080;

  if (proxy.host &#x26;&#x26; proxy.path) {
    // if both a `host` and `path` are specified then it&#x27;s most likely the
    // result of a `url.parse()` call... we need to remove the `path` portion so
    // that `net.connect()` doesn&#x27;t attempt to open that as a unix socket file.
    delete proxy.path;
    delete proxy.pathname;
  }

  // figure out if we want socks v4 or v5, based on the &#x22;protocol&#x22; used.
  // Defaults to 5.
  proxy.lookup = false;
  switch (proxy.protocol) {
    case &#x27;socks4:&#x27;:
      proxy.lookup = true;
      // pass through
    case &#x27;socks4a:&#x27;:
      proxy.version = 4;
      break;
    case &#x27;socks5:&#x27;:
      proxy.lookup = true;
      // pass through
    case &#x27;socks:&#x27;: // no version specified, default to 5h
    case &#x27;socks5h:&#x27;:
      proxy.version = 5;
      break;
    default:
      throw new TypeError(&#x27;A &#x22;socks&#x22; protocol must be specified! Got: &#x27; + proxy.protocol);
  }

  this.proxy = proxy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.proxy-agent.proxies.socks" id="apidoc.module.proxy-agent.proxies.socks">module proxy-agent.proxies.socks</a></h1>


    <h2>
        <a href="#apidoc.element.proxy-agent.proxies.socks.socks" id="apidoc.element.proxy-agent.proxies.socks.socks">
        function <span class="apidocSignatureSpan">proxy-agent.proxies.</span>socks
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SocksProxyAgent(opts) {
  if (!(this instanceof SocksProxyAgent)) return new SocksProxyAgent(opts);
  if (&#x27;string&#x27; == typeof opts) opts = url.parse(opts);
  if (!opts) throw new Error(&#x27;a SOCKS proxy server `host` and `port` must be specified!&#x27;);
  Agent.call(this, connect);

  var proxy = extend({}, opts);

  // prefer `hostname` over `host`, because of `url.parse()`
  proxy.host = proxy.hostname || proxy.host;

  // SOCKS doesn&#x27;t *technically* have a default port, but this is
  // the same default that `curl(1)` uses
  proxy.port = +proxy.port || 1080;

  if (proxy.host &#x26;&#x26; proxy.path) {
    // if both a `host` and `path` are specified then it&#x27;s most likely the
    // result of a `url.parse()` call... we need to remove the `path` portion so
    // that `net.connect()` doesn&#x27;t attempt to open that as a unix socket file.
    delete proxy.path;
    delete proxy.pathname;
  }

  // figure out if we want socks v4 or v5, based on the &#x22;protocol&#x22; used.
  // Defaults to 5.
  proxy.lookup = false;
  switch (proxy.protocol) {
    case &#x27;socks4:&#x27;:
      proxy.lookup = true;
      // pass through
    case &#x27;socks4a:&#x27;:
      proxy.version = 4;
      break;
    case &#x27;socks5:&#x27;:
      proxy.lookup = true;
      // pass through
    case &#x27;socks:&#x27;: // no version specified, default to 5h
    case &#x27;socks5h:&#x27;:
      proxy.version = 5;
      break;
    default:
      throw new TypeError(&#x27;A &#x22;socks&#x22; protocol must be specified! Got: &#x27; + proxy.protocol);
  }

  this.proxy = proxy;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.proxy-agent.proxies.socks.super_" id="apidoc.element.proxy-agent.proxies.socks.super_">
        function <span class="apidocSignatureSpan">proxy-agent.proxies.socks.</span>super_
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Agent(callback) {
  if (!(this instanceof Agent)) return new Agent(callback);
  if (&#x27;function&#x27; != typeof callback) throw new Error(&#x27;Must pass a &#x22;callback function&#x22;&#x27;);
  EventEmitter.call(this);
  this.callback = callback;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.proxy-agent.super_" id="apidoc.module.proxy-agent.super_">module proxy-agent.super_</a></h1>


    <h2>
        <a href="#apidoc.element.proxy-agent.super_.super_" id="apidoc.element.proxy-agent.super_.super_">
        function <span class="apidocSignatureSpan">proxy-agent.</span>super_
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EventEmitter() {
  EventEmitter.init.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.proxy-agent.super_.prototype" id="apidoc.module.proxy-agent.super_.prototype">module proxy-agent.super_.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.proxy-agent.super_.prototype.addRequest" id="apidoc.element.proxy-agent.super_.prototype.addRequest">
        function <span class="apidocSignatureSpan">proxy-agent.super_.prototype.</span>addRequest
        <span class="apidocSignatureSpan">(req, host, port, localAddress)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addRequest = function (req, host, port, localAddress) {
  var opts;
  if (&#x27;object&#x27; == typeof host) {
    // &#x3e;= v0.11.x API
    opts = extend({}, req._options, host);
  } else {
    // &#x3c;= v0.10.x API
    opts = extend({}, req._options, { host: host, port: port });
    if (null != localAddress) {
      opts.localAddress = localAddress;
    }
  }

  if (opts.host &#x26;&#x26; opts.path) {
    // if both a `host` and `path` are specified then it&#x27;s most likely the
    // result of a `url.parse()` call... we need to remove the `path` portion so
    // that `net.connect()` doesn&#x27;t attempt to open that as a unix socket file.
    delete opts.path;
  }

  // set default `port` if none was explicitly specified
  if (null == opts.port) {
    opts.port = opts.secureEndpoint ? 443 : 80;
  }

  delete opts.agent;
  delete opts.hostname;
  delete opts._defaultAgent;
  delete opts.defaultPort;
  delete opts.createConnection;

  // hint to use &#x22;Connection: close&#x22;
  // XXX: non-documented `http` module API :(
  req._last = true;
  req.shouldKeepAlive = false;

  // clean up a bit of memory since we&#x27;re no longer using this
  req._options = null;

  // create the `net.Socket` instance
  var sync = true;
  this.callback(req, opts, function (err, socket) {
    function emitErr () {
      req.emit(&#x27;error&#x27;, err);
      // For Safety. Some additional errors might fire later on
      // and we need to make sure we don&#x27;t double-fire the error event.
      req._hadError = true;
    }
    if (err) {
      if (sync) {
        // need to defer the &#x22;error&#x22; event, when sync, because by now the `req`
        // instance hasn&#x27;t event been passed back to the user yet...
        process.nextTick(emitErr);
      } else {
        emitErr();
      }
    } else {
      req.onSocket(socket);
    }
  });
  sync = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   if (agent) exports.cache.set(key, agent);
 } else {
   debug(&#x27;cache hit with key: %o&#x27;, key);
 }

 // XXX: agent.callback() is an agent-base-ism
 // TODO: add support for generic `http.Agent` instances by calling
 // agent.<span class="apidocCodeKeywordSpan">addRequest</span>(), but with support for &#x3c;= 0.10.x and &#x3e;= 0.12.x
 agent.callback(req, opts, fn);
}

/**
* Returns an Array of supported protocol string names.
*
* @return {Array}
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
